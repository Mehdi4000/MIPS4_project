<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Système Anti-Triche - Examen en Ligne</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: #fff;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    nav {
      background: rgba(255, 255, 255, 0.1);
      padding: 1rem;
      position: fixed;
      width: 100%;
      z-index: 10;
    }
    nav a {
      color: #fff;
      text-decoration: none;
      margin: 0 1rem;
    }
    nav a:hover {
      color: #00ffcc;
    }
    .container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      flex: 1;
      padding: 2rem;
      margin-top: 80px;
      gap: 1rem;
    }
    .video-container {
      position: relative;
    }
    #webcam {
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    #alert {
      background: rgba(255, 50, 50, 0.8);
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
      display: none;
      font-weight: bold;
    }
    .status {
      margin-top: 1rem;
      font-size: 1.2rem;
    }
    .form-container {
      background: rgba(255, 255, 255, 0.1);
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      width: 300px;
    }
    .form-container label {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      display: block;
    }
    .form-container input, .form-container textarea {
      width: 100%;
      padding: 0.5rem;
      border: none;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 1rem;
      margin-bottom: 1rem;
    }
    .form-container input[readonly], .form-container textarea[readonly] {
      cursor: not-allowed;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    .alert-active {
      animation: pulse 1s infinite;
    }
  </style>



</head>
<body>
  <nav>
    <a href="#home">Accueil</a>
    <a href="#exam">Examen</a>
    <a href="#profile">Profil</a>
  </nav>
  <div class="container">
    <div class="video-container">
      <video id="webcam" autoplay playsinline width="640" height="480"></video>
      <canvas id="canvas" width="640" height="480"></canvas>
      <div id="alert">Comportement suspect détecté ! Veuillez rester face à l'écran.</div>
      <div class="status">Statut : Surveillance active</div>
    </div>
    <div class="form-container">
      <form>
        <label for="faceCount">Nombre de visages détectés :</label>
        <input type="number" id="faceCount" value="0" readonly>
        <label for="gazeStatus">État du regard :</label>
        <input type="text" id="gazeStatus" value="Normal" readonly>
        <label for="objectStatus">Objets détectés :</label>
        <textarea id="objectStatus" readonly></textarea>
      </form>
    </div>
  </div>

  <script>
    function showError(message) {
      const alertElement = document.getElementById('alert');
      alertElement.textContent = message;
      alertElement.style.display = 'block';
      console.error(message);
    }

    if (typeof FaceMesh === 'undefined') {
      showError('Erreur : FaceMesh n\'est pas chargé.');
      throw new Error('FaceMesh not loaded');
    }

    if (typeof tf === 'undefined') {
      showError('Erreur : TensorFlow.js n\'est pas chargé.');
      throw new Error('TensorFlow.js not loaded');
    }

    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const alertElement = document.getElementById('alert');
    const faceCountInput = document.getElementById('faceCount');
    const gazeStatusInput = document.getElementById('gazeStatus');
    const objectStatusInput = document.getElementById('objectStatus');
    let alertCount = 0;
    let outOfFrameCount = 0;
    let gazeOffScreenCount = 0;
    let objectModel;

    //le modele COCO-SSD:
    async function loadObjectDetectionModel() {
      try {
        objectModel = await cocoSsd.load();
        console.log('COCO-SSD model loaded');
      } catch (err) {
        showError('Erreur lors du chargement de COCO-SSD : ' + err.message);
      }
    }
    loadObjectDetectionModel();

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`,
    });

    faceMesh.setOptions({
      maxNumFaces: 2,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    faceMesh.onResults(async (results) => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

      alertElement.style.display = 'none';
      alertElement.classList.remove('alert-active');

      const faceCount = results.multiFaceLandmarks ? results.multiFaceLandmarks.length : 0;
      faceCountInput.value = faceCount;

      // Detection des objets:
      if (objectModel) {
        try {
          const predictions = await objectModel.detect(videoElement);
          let detectedObjects = [];
          predictions.forEach((prediction) => {
            if (['cell phone', 'book'].includes(prediction.class) && prediction.score > 0.5) {
              detectedObjects.push(prediction.class);
              canvasCtx.beginPath();
              canvasCtx.rect(prediction.bbox[0], prediction.bbox[1], prediction.bbox[2], prediction.bbox[3]);
              canvasCtx.strokeStyle = 'yellow';
              canvasCtx.lineWidth = 2;
              canvasCtx.stroke();
            }
          });
          objectStatusInput.value = detectedObjects.length > 0 ? detectedObjects.join(', ') : 'Aucun';
          if (detectedObjects.includes('cell phone')) {
            alertElement.style.display = 'block';
            alertElement.classList.add('alert-active');
            alertElement.textContent = 'Téléphone détecté ! Les appareils sont interdits.';
            console.log('Cell phone detected!');
            //alerte triche!!
          }
        } catch (err) {
          console.error('Object detection error:', err);
        }
      }

      if (results.multiFaceLandmarks) {
        for (const landmarks of results.multiFaceLandmarks) {
          const leftEye = landmarks[33];
          const rightEye = landmarks[263];
          const nose = landmarks[1];
          const leftCheek = landmarks[234];
          const rightCheek = landmarks[454];

          // Dessiner le cadre autour du visage
          const minX = Math.min(leftEye.x, leftCheek.x, rightEye.x, rightCheek.x) * canvasElement.width;
          const maxX = Math.max(leftEye.x, leftCheek.x, rightEye.x, rightCheek.x) * canvasElement.width;
          const minY = Math.min(leftEye.y, nose.y, rightEye.y) * canvasElement.height;
          const maxY = Math.max(leftEye.y, nose.y, rightEye.y) * canvasElement.height;
          canvasCtx.beginPath();
          canvasCtx.rect(minX - 20, minY - 20, maxX - minX + 40, maxY - minY + 40);
          canvasCtx.strokeStyle = 'green';
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();

          // Dessiner les points des yeux
          [33, 263].forEach((index) => {
            const landmark = landmarks[index];
            const x = landmark.x * canvasElement.width;
            const y = landmark.y * canvasElement.height;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 3, 0, 2 * Math.PI);
            canvasCtx.fillStyle = 'red';
            canvasCtx.fill();
          });

          // Detection du regard hors écran
          const eyeCenterX = (leftEye.x + rightEye.x) / 2;
          const eyeCenterY = (leftEye.y + rightEye.y) / 2;
          const gazeDeviationX = Math.abs(eyeCenterX - nose.x);
          const gazeDeviationY = Math.abs(eyeCenterY - nose.y);
          if (gazeDeviationX > 0.1 || gazeDeviationY > 0.15) {
            gazeOffScreenCount++;
            if (gazeOffScreenCount > 30) {
              gazeStatusInput.value = 'Regard hors écran';
              alertElement.style.display = 'block';
              alertElement.classList.add('alert-active');
              alertElement.textContent = 'Regard hors écran ! Veuillez regarder l\'écran.';
              console.log('Gaze off screen!');
            }
          } else {
            gazeStatusInput.value = 'Normal';
            gazeOffScreenCount = 0;
          }

          // Verifier si le visage est dans le cadre
          const isOutOfFrame = minX < 0 || maxX > canvasElement.width || minY < 0 || maxY > canvasElement.height;
          if (isOutOfFrame) {
            outOfFrameCount++;
            if (outOfFrameCount > 30) {
              alertElement.style.display = 'block';
              alertElement.classList.add('alert-active');
              alertElement.textContent = 'Visage hors du cadre ! Veuillez rester dans le champ de la caméra.';
              console.log('Face out of frame!');
            }
          } else {
            outOfFrameCount = 0;
          }

          // Detecter la rotation du visage::
          const headRotation = Math.abs(nose.x - (leftEye.x + rightEye.x) / 2);
          const verticalGaze = nose.y;
          if (!isOutOfFrame && (headRotation > 0.3 || verticalGaze < 0.3 || verticalGaze > 0.7)) {
            alertCount++;
            if (alertCount > 30) {
              alertElement.style.display = 'block';
              alertElement.classList.add('alert-active');
              alertElement.textContent = 'Comportement suspect détecté ! Veuillez rester face à l\'écran.';
              console.log('Suspicious behavior detected!');
            }
          } else {
            alertCount = 0;
          }
        }

        if (faceCount > 1) {
          alertElement.style.display = 'block';
          alertElement.classList.add('alert-active');
          alertElement.textContent = 'Plusieurs visages détectés ! Un seul étudiant est autorisé.';
          console.log('Multiple faces detected!');
        }
      } else {
        alertCount++;
        outOfFrameCount++;
        gazeStatusInput.value = 'Aucun visage';
        if (alertCount > 30) {
          alertElement.style.display = 'block';
          alertElement.classList.add('alert-active');
          alertElement.textContent = 'Aucun visage détecté ! Veuillez rester face à la caméra.';
          console.log('No face detected!');
        }
        if (outOfFrameCount > 30) {
          alertElement.style.display = 'block';
          alertElement.classList.add('alert-active');
          alertElement.textContent = 'Visage hors du cadre ! Veuillez rester dans le champ de la caméra.';
          console.log('Face out of frame!');
        }
      }
      canvasCtx.restore();
    });

    try {
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await faceMesh.send({ image: videoElement });
        },
        width: 640,
        height: 480,
      });
      camera.start().catch((err) => {
        showError('Erreur lors de l\'accès à la webcam : ' + err.message);
      });
    } catch (err) {
      showError('Erreur lors de l\'initialisation de la caméra : ' + err.message);
    }
  </script>
</body>
</html>